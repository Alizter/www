<p>Coq is a proof assistant. It means that it is designed to develop
mathematical proofs, and especially to write formal specifications,
programs and proofs that programs complies to their specifications. An
interesting feature of Coq is that it can automatically extract
executable programs from specifications, as either OCaml or Haskel
source code.</p>

<p>Properties, programs and proofs are formalized in the
same language called the Calculus of Inductive Constructions (CIC). The
CIC is a lambda-calculus with a rich type system. Then, all logical
judgments in Coq are typing judgments: the very heart of Coq is in
fact a type-checking algorithm.</p>


<h3>A rich type system</h3>

The type of a sorting function over lists of natural numbers in a "poor" type system would be:

<pre>sort : list nat -> list nat</pre>

The rich type system of Coq allows to be more specific:

<pre>sort : (l : list nat) -> {l' : list nat | sorted l' /\ same_elements l l'}</pre>

<p>where <tt>sorted</tt> is a predicate that states whether a list is sorted 
or not; and <tt>all_elements</tt> states whether two lists contains the same elements.</p>

<p>Such a type (specification) enforces the user to write the proofs of predicates <tt>sorted l'</tt> and <tt>same_elements l l'</tt> when writing a implementation for the function <tt>sort</tt>.</p>

<h3>Inductive types</h3>

<p>Another interesting feature of the language of Coq is the ability to
define inductive types. For example, the type of natural numbers can
be defined by:</p>

<pre>
	Inductive nat : Set :=
	  | 0 : nat
	  | S : nat -> nat.
</pre>

Along with the type, Coq generates elimination principles named
<tt>nat_ind</tt>, <tt>nat_rec</tt> and <tt>nat_rect</tt>, depending on which sort the principles are expressed in. For example, <tt>nat_ind</tt> is:

<pre>
	forall P : nat -> Prop,
	  P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n
</pre>

Inductive types can be used to define logical properties. For example,
we can define the predicate "less or equal" the following way:

<pre>
	Inductive le (n:nat) : nat -> Prop :=
	  | le_n : le n n
	  | le_S : forall m:nat, le n m -> le n (S m)
</pre>

<p>Then, functions over inductive types are expressed using a case
analysis:</p>

<pre>
	Fixpoint plus (n m:nat) {struct n} : nat :=
	  match n with
	    | O => m
	    | S p => S (p + m)
	  end
</pre>


<h3>Proving in coq</h3>

<p>Proof development in Coq is done through a language of tactics. Tactics
allow to build a lambda-term step by step. For example the tactic
<tt>intro n</tt>, where <tt>n</tt> is of type <tt>nat</tt>, builds the term (with a hole):</p>

<pre>
	fun (n:nat) => _ 
</pre>

<p>where _ represents a term that will be constructed after, using other
tactics.</p>

<p>Here is an example of a proof in the Coq system:</p>

<pre>
	Inductive sequ : nat -> Set :=
	  void : sequ 0
	| cons : forall n : nat, nat -> sequ n -> sequ (S n).

	Fixpoint length (n : nat) (s : sequ n) {struct s} : nat := 
	  match s with
	    | void => 0
	    | cons i _ s' => S (length i s')
	  end.

	Theorem length_corr : forall (n : nat) (s : sequ n), length s = n.
	Proof.
	  intros n s.

	  (* elim uses the induction principle sequ_ind on the current
             goal. Then, we have two new goal corresponding on the
 	     case analysis about n (either it is void or some cons *)
	  elim s.

	    (* We are in the case where s is void. We can reduce the
	       term: length n void *)
	    simpl. 

	    (* We obtain the goal 0 = 0. *)
	    trivial.

	    (* now, we treat the case s = cons n' e s' *)	    
	    intros n' e s' IH.
	    simpl. 

	    (* IH is the induction hypothesis; its type is:
	       length n' s' = n'. So we can use it to perform some
	       rewriting in the goal: *)
	    rewrite IH. 

	    (* Now the goal is the trivial equality: S n' = S n' *)
	    trivial.

	  (* Now all sub cases are closed, we perform the ultimate
	     step: typing the term built using tactics and save it as
	     a witness of the theorem. *)
        Qed.	  
</pre>

<p>Using the Print command, the user can check the term generated using the tactics:</p>

<pre>
	length_corr = 
	  fun (n : nat) (s : sequ n) =>
		sequ_ind (fun (n0 : nat) (s0 : sequ n0) => length n0 s0 = n0) 
		  (refl_equal 0)
		  (fun (n' _ : nat) (s' : sequ n') (IH : length n' s' = n') =>
		     eq_ind_r 
			(fun n0 : nat => S n0 = S n') 
			(refl_equal (S n')) IH) n s
	     : forall (n : nat) (s : sequ n), length n s = n
</pre>
