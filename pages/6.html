<p>Coq is a proof assistant. It means that it is designed to develop
mathematical proofs, and especially to write formal specifications,
programs and proofs that programs comply to their specifications. An
interesting feature of Coq is that it can automatically extract
executable programs from specifications, as either <a href="http://caml.inria.fr/ocaml">Objective Caml</a> or <a href="http://www.haskell.org">Haskell</a>
source code.</p>

<p>Properties, programs and proofs are formalized in the
same language called the Calculus of Inductive Constructions (CIC). The
CIC is a lambda-calculus with a rich type system. Then, all logical
judgments in Coq are typing judgments: the very heart of Coq is in
fact a <em>type</em>-checking algorithm.</p>

<h3>Coq basically manipulates two <em>sorts</em> of objects: <tt>Prop</tt> and <tt>Type</tt></h3>

<ul>
<li><tt>Prop</tt> is for propositions, i.e. well-formed propositions are of <em>type</em> <tt>Prop</tt>. 
Typical propositions are:
<quote>
<pre>
        ? A B : Prop, A /\ B -> B \/ B
        ? x y : Z, x * y = 0 -> x = 0 \/ y = 0
</pre>
</quote>
and new predicates can be defined either inductively, e.g.:
<quote>
<pre>
        Inductive even : N -> Prop :=
        | even_0 : even 0
        | even_S n : odd n -> even (n + 1)
        with odd : N -> Prop :=
        | odd_S n : even n -> odd (n + 1).
</pre>
</quote>
or by abstracting over other existing propositions, e.g.:
<br>
<quote>
<pre>
        Definition divide (x y:Z) := ? z, x * z = y.
        Definition prime x := ? y, divide y x -> y = 1 \/ y = x.
</pre>
</quote>
</li>

<li><tt>Type</tt> is for datatypes and mathematical structures, i.e. well-formed types or structures are of <em>type</em> <tt>Type</tt>. Here is e.g. a basic example of type:
<quote>
<pre>
        Z -> Z * Z
</pre>
</quote>
Types can be inductive structures, e.g.:
<quote>
<pre>
	Inductive nat : Set :=
	| 0 : nat
	| S : nat -> nat.

        Inductive list (A:Type) : Type :=
        | nil : list A
        | cons : A -> list A -> list A.
</pre>
</quote>
or tuples, e.g.:
<quote>
<pre>
        Structure monoid := { 
          dom : Type ; op : dom -> dom -> dom ; id : dom ; 
          assoc : ? x y z, x * (y * z) = (x * y) * z ; 
          left_neutral : ? x, 1 * x = x ; right_neutral : ? x, x * 1 = x 
        } where "x * y" := (x * y).
</pre>
</quote>
or a form of subset types called ?-types, e.g. the type of even natural numbers:
<pre>
        {n : N | even n}
</pre>
</li>
</ul>

<h3>A richly-typed functional programming language</h3>

<p>
The type of a sorting function over lists of natural numbers in a "poor" type system would be:

<pre>
        sort : list nat -> list nat
</pre>

Thanks to subset types, Coq allows to be more specific:
<pre>
        sort : ? (l : list nat), {l' : list nat | sorted l' /\ same_elements l l'}
</pre>
where <tt>sorted</tt> is a predicate that expresses that a list is sorted; and <tt>all_elements</tt> says if two lists contain the same elements.
</p>

<p>Such a type (specification) enforces the user to write the proofs of predicates <tt>sorted l'</tt> and <tt>same_elements l l'</tt> when writing a implementation for the function <tt>sort</tt>.</p>

<p>Then, functions over inductive types are expressed using a case
analysis:</p>

<pre>
	Fixpoint plus (n m:nat) {struct n} : nat :=
	  match n with
	    | O => m
	    | S p => S (p + m)
	  end
</pre>


<h3>Proving in coq</h3>

<p>Proof development in Coq is done through a language of tactics that 
allow interactive step by step development. 


At the end, the curious user can chack that tactics build lambda-terms. For example the tactic
<tt>intro n</tt>, where <tt>n</tt> is of type <tt>nat</tt>, builds the term (with a hole):</p>

<pre>
	fun (n:nat) => _ 
</pre>

<p>where _ represents a term that will be constructed after, using other
tactics.</p>

<p>Here is an example of a proof in the Coq system:</p>

<pre>
	Inductive sequ : nat -> Set :=
	  void : sequ 0
	| cons : forall n : nat, nat -> sequ n -> sequ (S n).

	Fixpoint length (n : nat) (s : sequ n) {struct s} : nat := 
	  match s with
	    | void => 0
	    | cons i _ s' => S (length i s')
	  end.

	Theorem length_corr : forall (n : nat) (s : sequ n), length s = n.
	Proof.
	  intros n s.

	  (* elim uses the induction principle sequ_ind on the current
             goal. Then, we have two new goal corresponding on the
 	     case analysis about n (either it is void or some cons *)
	  elim s.

	    (* We are in the case where s is void. We can reduce the
	       term: length n void *)
	    simpl. 

	    (* We obtain the goal 0 = 0. *)
	    trivial.

	    (* now, we treat the case s = cons n' e s' *)	    
	    intros n' e s' IH.
	    simpl. 

	    (* IH is the induction hypothesis; its type is:
	       length n' s' = n'. So we can use it to perform some
	       rewriting in the goal: *)
	    rewrite IH. 

	    (* Now the goal is the trivial equality: S n' = S n' *)
	    trivial.

	  (* Now all sub cases are closed, we perform the ultimate
	     step: typing the term built using tactics and save it as
	     a witness of the theorem. *)
        Qed.	  
</pre>

<p>Using the Print command, the user can check the term generated using the tactics:</p>

<pre>
	length_corr = 
	  fun (n : nat) (s : sequ n) =>
		sequ_ind (fun (n0 : nat) (s0 : sequ n0) => length n0 s0 = n0) 
		  (refl_equal 0)
		  (fun (n' _ : nat) (s' : sequ n') (IH : length n' s' = n') =>
		     eq_ind_r 
			(fun n0 : nat => S n0 = S n') 
			(refl_equal (S n')) IH) n s
	     : forall (n : nat) (s : sequ n), length n s = n
</pre>