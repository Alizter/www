
<H1 CLASS="chapter">Modules</H1><!--SEC END -->

<!--TOC section Opening library modules-->

<br/>

<H2 CLASS="section"><A NAME="htoc28">3.1</A>&nbsp;&nbsp;Opening library modules</H2><!--SEC END -->

When you start <SPAN STYLE="font-variant:small-caps">Coq</SPAN>&nbsp; without further requirements in the command line,
you get a bare system with few libraries loaded. As we saw, a standard
prelude module provides the standard logic connectives, and a few
arithmetic notions. If you want to load and open other modules from
the library, you have to use the <CODE>Require</CODE> command, as we saw for
classical logic above. For instance, if you want more arithmetic
constructions, you should request:

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Arith.</TT><BR>
</DIV>
<BR>
<BR>
Such a command looks for a (compiled) module file <CODE>Arith.vo</CODE> in
the libraries registered by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. Libraries inherit the structure of
the file system of the operating system and are registered with the
command <CODE>Add LoadPath</CODE>. Physical directories are mapped to
logical directories. Especially the standard library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>&nbsp; is
pre-registered as a library of name <CODE>Coq</CODE>. Modules have absolute
unique names denoting their place in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>&nbsp; libraries. An absolute
name is a sequence of single identifiers separated by dots. E.g. the
module <CODE>Arith</CODE> has full name <CODE>Coq.Arith.Arith</CODE> and because
it resides in eponym subdirectory <CODE>Arith</CODE> of the standard
library, it can be as well required by the command<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Require&nbsp;Import&nbsp;Coq.Arith.Arith.</TT><BR>
</DIV>
<BR>
<BR>
This may be useful to avoid ambiguities if somewhere, in another branch
of the libraries known by Coq, another module is also called
<CODE>Arith</CODE>. Notice that by default, when a library is registered,
all its contents, and all the contents of its subdirectories recursively are
visible and accessible by a short (relative) name as <CODE>Arith</CODE>.
Notice also that modules or definitions not explicitly registered in
a library are put in a default library called <CODE>Top</CODE>.<BR>
<BR>
The loading of a compiled file is quick, because the corresponding
development is not type-checked again. <BR>
<BR>
<!--TOC section Creating your own modules-->

<H2 CLASS="section"><A NAME="htoc29">3.2</A>&nbsp;&nbsp;Creating your own modules</H2><!--SEC END -->

You may create your own modules, by writing <SPAN STYLE="font-variant:small-caps">Coq</SPAN>&nbsp; commands in a file,
say <CODE>my_module.v</CODE>. Such a module may be simply loaded in the current
context, with command <CODE>Load my_module</CODE>. It may also be compiled,
in &#8220;batch&#8221; mode, using the UNIX command
<CODE>coqc</CODE>. Compiling the module <CODE>my_module.v</CODE> creates a 
file <CODE>my_module.vo</CODE> that can be reloaded with command
<CODE>Require Import my_module</CODE>. <BR>
<BR>
If a required module depends on other modules then the latters are
automatically required beforehand. However their contents is not
automatically visible. If you want a module <CODE>M</CODE> required in a
module <CODE>N</CODE> to be automatically visible when <CODE>N</CODE> is required,
you should use <CODE>Require Export M</CODE> in your module <CODE>N</CODE>.<BR>
<BR>
<!--TOC section Managing the context-->

<H2 CLASS="section"><A NAME="htoc30">3.3</A>&nbsp;&nbsp;Managing the context</H2><!--SEC END -->

It is often difficult to remember the names of all lemmas and
definitions available in the current context, especially if large
libraries have been loaded. A convenient <CODE>SearchAbout</CODE> command
is available to lookup all known facts 
concerning a given predicate. For instance, if you want to know all the
known lemmas about the less or equal relation, just ask:

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;SearchAbout&nbsp;le.</TT><BR>
<TT><I>tricky:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;0&nbsp;-&gt;&nbsp;n&nbsp;=&nbsp;0</I></TT><BR>
<TT><I>Top.le_n_S:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m)</I></TT><BR>
<TT><I>le_ind:</I></TT><BR>
<TT><I>&nbsp;&nbsp;forall&nbsp;(n&nbsp;:&nbsp;nat)&nbsp;(P&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop),</I></TT><BR>
<TT><I>&nbsp;&nbsp;P&nbsp;n&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;(forall&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;m&nbsp;-&gt;&nbsp;P&nbsp;(S&nbsp;m))&nbsp;-&gt;</I></TT><BR>
<TT><I>&nbsp;&nbsp;forall&nbsp;n0&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;n0&nbsp;-&gt;&nbsp;P&nbsp;n0</I></TT><BR>
<TT><I>le_n:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;n</I></TT><BR>
<TT><I>le_S:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;n&nbsp;(S&nbsp;m)</I></TT><BR>
</DIV>

Another command <CODE>Search</CODE> displays only lemmas where the searched
predicate appears at the head position in the conclusion.

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;Search&nbsp;le.</TT><BR>
<TT><I>Top.le_n_S:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;(S&nbsp;n)&nbsp;(S&nbsp;m)</I></TT><BR>
<TT><I>le_n:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;n</I></TT><BR>
<TT><I>le_S:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;le&nbsp;n&nbsp;m&nbsp;-&gt;&nbsp;le&nbsp;n&nbsp;(S&nbsp;m)</I></TT><BR>
</DIV>
<BR>
<BR>
A new and more convenient search tool is <FONT COLOR=purple>SearchPattern</FONT>
developed by Yves Bertot. It allows to find the theorems with a
conclusion matching a given pattern, where <CODE>\_</CODE> can be used in
place of an arbitrary term. We remark in this example, that <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
provides usual infix notations for arithmetic operators.<BR>
<BR>

<DIV CLASS="flushleft">
<TT>Coq&nbsp;&lt;&nbsp;SearchPattern&nbsp;(_&nbsp;+&nbsp;_&nbsp;=&nbsp;_).</TT><BR>
<TT><I>le_plus_minus_r:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;&lt;=&nbsp;m&nbsp;-&gt;&nbsp;n&nbsp;+&nbsp;(m&nbsp;-&nbsp;n)&nbsp;=&nbsp;m</I></TT><BR>
<TT><I>mult_acc_aux:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;:&nbsp;nat,&nbsp;m&nbsp;+&nbsp;n&nbsp;*&nbsp;p&nbsp;=&nbsp;mult_acc&nbsp;m&nbsp;p&nbsp;n</I></TT><BR>
<TT><I>plus_O_n:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;0&nbsp;+&nbsp;n&nbsp;=&nbsp;n</I></TT><BR>
<TT><I>plus_Sn_m:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;S&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;S&nbsp;(n&nbsp;+&nbsp;m)</I></TT><BR>
<TT><I>mult_n_Sm:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;*&nbsp;m&nbsp;+&nbsp;n&nbsp;=&nbsp;n&nbsp;*&nbsp;S&nbsp;m</I></TT><BR>
<TT><I>plus_0_l:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;0&nbsp;+&nbsp;n&nbsp;=&nbsp;n</I></TT><BR>
<TT><I>plus_0_r:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;0&nbsp;=&nbsp;n</I></TT><BR>
<TT><I>plus_comm:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;m&nbsp;+&nbsp;n</I></TT><BR>
<TT><I>plus_Snm_nSm:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;S&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;n&nbsp;+&nbsp;S&nbsp;m</I></TT><BR>
<TT><I>plus_assoc:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;(m&nbsp;+&nbsp;p)&nbsp;=&nbsp;n&nbsp;+&nbsp;m&nbsp;+&nbsp;p</I></TT><BR>
<TT><I>plus_permute:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;(m&nbsp;+&nbsp;p)&nbsp;=&nbsp;m&nbsp;+&nbsp;(n&nbsp;+&nbsp;p)</I></TT><BR>
<TT><I>plus_assoc_reverse:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;+&nbsp;p&nbsp;=&nbsp;n&nbsp;+&nbsp;(m&nbsp;+&nbsp;p)</I></TT><BR>
<TT><I>plus_permute_2_in_4:&nbsp;forall&nbsp;n&nbsp;m&nbsp;p&nbsp;q&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;+&nbsp;(p&nbsp;+&nbsp;q)&nbsp;=&nbsp;n&nbsp;+&nbsp;p&nbsp;+&nbsp;(m&nbsp;+&nbsp;q)</I></TT><BR>
<TT><I>plus_tail_plus:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;tail_plus&nbsp;n&nbsp;m</I></TT><BR>
<TT><I>plus_com:&nbsp;forall&nbsp;n&nbsp;m&nbsp;:&nbsp;nat,&nbsp;n&nbsp;+&nbsp;m&nbsp;=&nbsp;m&nbsp;+&nbsp;n</I></TT><BR>
</DIV>
<BR>
<BR>
<!--TOC section Now you are on your own-->

<H2 CLASS="section"><A NAME="htoc31">3.4</A>&nbsp;&nbsp;Now you are on your own</H2><!--SEC END -->

This tutorial is necessarily incomplete. If you wish to pursue serious
proving in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, you should now get your hands on <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s Reference Manual,
which contains a complete description of all the tactics we saw, 
plus many more.
You also should look in the library of developed theories which is distributed
with <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, in order to acquaint yourself with various proof techniques.<BR>
<BR>